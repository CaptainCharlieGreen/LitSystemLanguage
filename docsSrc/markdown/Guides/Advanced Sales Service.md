# Advanced Guide: Sales Service

In this guide we'll create our own sales service and use that instead of the public one we included in the [Bookstore Guide](./Bookstore).  If you haven't completed the Bookstore Guide, do that first.  The topics covered here should be the last bits needed to create a application with Strat.  We'll learn how to:

  - manage access to resources outside of Strat (like a database)
  - externalize APIs using the public keyword
  - use a new standard library source Cron to schedule tasks
  - configure SVS behavior with an svs.json
  - build a javascript bundle artifact

Lets start with a bare-bones Sales api:

Sales.st:
```st
service Sales {
  public getSales ():any -> "./getSales.js"
}
```

getSales.js:
```javascript
module.exports = () => [ 'John Steinbeck' ];
```

Notice how we're not including Http--that public keyword sets up Http for us. Lets run this and poke around some endpoints:

```
stratc Sales.st && stratc Sales.sa
```

[localhost:3000](http://localhost:3000/) gives a not found as expected--we didn't dispatch any Http events. However, the public keyword generates a few endpoints under the path '/strat/Sales/' for us that other APIs can use to connect to our Sales service.

  - [localhost:3000/strat/Sales/Sales.st](http://localhost:3000/strat/Sales/Sales.st) is a Strat file that clients can use to include our Sales service.
  - [localhost:3000/strat/Sales/client.js](http://localhost:3000/strat/Sales/client.js) is a client file generated by stratc that clients use to connect to our service.
  - [localhost:3000/strat/Sales/getSales](http://localhost:3000/strat/Sales/getSales) is our "public" getSales function that clients will call and get routed to our getSales.js file.

Lets run this and use it in our Books API.  But first, we need to sort out how to run the two APIs on different ports as they can't both use 3000.  Create a file svs.json:

```json
{
  "substrate": "local",
  "local": {
    "Http": {
      "port": 3001
    }
  }
}
```

svs.json is the vehicle for supplying behavior overrides to whichever SVS is running our .sa file.  Its not part of the Strat language, but sometimes SVS implementations need more information to run .sa files and users may wish to provide explicit infrastructure details like permissions, which we'll see later.  Run our sales service, which will now run on [localhost:3001/strat/Sales/Sales.st](http://localhost:3001/strat/Sales/Sales.st).  Now, back in our Bookstore.st file change the Sales include from:

```st
include "https://s0tjdzrsha.execute-api.us-west-2.amazonaws.com/Sales/strat/Sales/Sales.st"
```

to
```st
include "http://localhost:3001/strat/Sales/Sales.st"
```
and re-run your Bookstore

```sh
stratc Bookstore.st && stratc Bookstore.sa
```

If you get an error 'ECONNREFUSED' its because you don't have your Sales service running--the Sales service needs to be running to communicate with stratc while Bookstore is building.  Just to prove to yourself that you do indeed have two independent services running on your machine, change the sales response in getSales.js from 'John Steinbeck' to 'Leo Tolstoy', rebuild the Sales service then rebuild the Bookstore.  You should see a little on sale indicator next to *War and Peace*.


## Database Access

Stateless compute is all fun and games, but almost all real web software has a persistence layer.  For this tutorial we'll be using a DynamoDB database.  If you're not familiar, [DynamoDB](https://aws.amazon.com/dynamodb/) is a managed NoSQL database available on AWS.  DDB backs most AWS services and therefore a substantial portion of the internet--its one of the rare technologies made for massive scale that's still user friendly and practical at smaller workloads.

Make a new file getSalesFromDDB.js:

```javascript
```



## Building A Javascript Bundle

We are at an unfortunate time in this guide.  We have a nice little database access file, but its not totally clear how we'll access this in our getSales.  We could make it its own function in Sales.st and call it from getSales by using Strat like we do in the Books service, but instead we'll bundle it into the getSales function.  Strat is rigid about what constitutes an artifact--single files that expose a single function.  For most languages this is pretty easy--the compiler for rust creates a single binary file, for example.  However, javascript is lacking in this regard, and we have to bring in some extra tools to create this nice single file bundle.  If you've already lived through the 7th circle of hell that is building javascript, go ahead and use whatever you're comfortable with.  We'll be using [Webpack](https://webpack.js.org/) here because it's the preeminent cause of mental breakdowns in the Javascript community--we want only the best.

Create a package.json file:

```json
{
  "name": "sales-demo",
  "main": "getSales.js",
  "devDependencies": {
    "webpack": "^4.29.6",
    "webpack-cli": "^3.3.0"
  },
  "dependencies": {
    "aws-sdk": "^2.434.0"
  }
}

```

Create a webpack.config.js file:
```js
const webpack = require('webpack');
const path = require('path');

module.exports = {
  target: 'node',
  entry: './getSales.js',
  output: {
    path: path.resolve('./'),
    filename: './getSales.bundle.js',
    library: 'strat-library',
    libraryTarget: 'umd'
  },
  optimization: {
    minimize: false
  },
  plugins: [
    new webpack.IgnorePlugin(/strat/gi)
  ],
};
```

Note: this configuration soup is why Webpack has such a bad reputation.  It's decent technology as long as somebody else hands you a working config file--you're welcome.

Install Webpack:
```sh
npm install
```

Run Webpack (note: requires npm 5+; use [n](https://www.npmjs.com/package/n) or [nvm](https://github.com/creationix/nvm/blob/master/README.md#installation-and-update) to upgrade your npm if npx doesn't work):

```sh
npx webpack
```
